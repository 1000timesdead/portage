diff --git a/configure.ac b/configure.ac
index c2869c4..13d725f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -79,6 +79,8 @@ AC_ARG_ENABLE(mp3,[  --disable-mp3           disable mp3 support (default: enabl
 AC_ARG_ENABLE(aac,[  --disable-aac           disable AAC support (default: enable)],[enable_aac=$enableval],[enable_aac=yes])
 AC_ARG_ENABLE(audiofile,[  --disable-audiofile     disable audiofile support, disables wave support (default: enable)],[enable_audiofile=$enableval],[enable_audiofile=yes])
 AC_ARG_ENABLE(mod,[  --enable-mod            enable MOD support (default: disable],[enable_mod=$enableval],[enable_mod=yes])
+AC_ARG_ENABLE(zlib,[  --disable-zlib           disable gzip and pkzip decompression support (default: enable)],[enable_zlib=$enableval],[enable_zlib=yes])
+AC_ARG_ENABLE(bzip2,[  --disable-bzip2           disable bzip2 decompression support (default: enable)],[enable_bzip2=$enableval],[enable_bzip2=yes])
 AC_ARG_ENABLE(mpc,[  --disable-mpc           disable musepack (MPC) support (default: enable)],[enable_mpc=$enableval],[enable_mpc=yes])
 AC_ARG_ENABLE(id3,[  --disable-id3           disable id3 support (default: enable)],[enable_id3=$enableval],[enable_id3=yes])
 
@@ -103,6 +105,14 @@ AC_ARG_WITH(faad-libraries,[  --with-faad-libraries=DIR   Directory where faad2
 AC_ARG_WITH(faad-includes,[  --with-faad-includes=DIR    Directory where faad2 header files are installed (optional)], faad_includes="$withval", faad_includes="")
 AC_ARG_WITH(zeroconf,[[  --with-zeroconf=[auto|avahi|bonjour|no]    Enable zeroconf backend (default=auto)]], with_zeroconf="$withval", with_zeroconf="auto")
 
+AC_ARG_WITH(bzip2,[  --with-bzip2=PFX             Prefix where bzip2 is installed], bzip2_prefix="$withval", bzip2_prefix="")
+AC_ARG_WITH(bzip2-libraries,[  --with-bzip2-libraries=DIR   Directory where bzip2 library is installed (optional)], bzip2_libraries="$withval", bzip2_libraries="")
+AC_ARG_WITH(bzip2-includes,[  --with-bzip2-includes=DIR    Directory where bzip2 header files are installed (optional)], bzip2_includes="$withval", bzip2_includes="")
+
+AC_ARG_WITH(zlib,[  --with-zlib=PFX             Prefix where zlib is installed], zlib_prefix="$withval", zlib_prefix="")
+AC_ARG_WITH(zlib-libraries,[  --with-zlib-libraries=DIR   Directory where zlib library is installed (optional)], zlib_libraries="$withval", zlib_libraries="")
+AC_ARG_WITH(zlib-includes,[  --with-zlib-includes=DIR    Directory where zlib header files are installed (optional)], zlib_includes="$withval", zlib_includes="")
+
 AC_C_BIGENDIAN
 
 AC_CHECK_SIZEOF(short)
@@ -618,6 +628,84 @@ if test x$with_zeroconf != xno; then
 	fi
 fi
 
+if test x$enable_zlib = xyes; then
+  	if test "x$zlib_libraries" != "x" ; then
+  		ZLIB_LIBS="-L$zlib_libraries"
+  	elif test "x$zlib_prefix" != "x" ; then
+		ZLIB_LIBS="-L$zlib_prefix/lib"
+  	elif test "x$prefix" != "xNONE"; then
+    		ZLIB_LIBS="-L$libdir"
+  	fi
+
+ 	ZLIB_LIBS="$ZLIB_LIBS -lz"
+
+  	if test "x$zlib_includes" != "x" ; then
+  		ZLIB_CFLAGS="-I$zlib_includes"
+  	elif test "x$zlib_prefix" != "x" ; then
+    		ZLIB_CFLAGS="-I$zlib_prefix/include"
+  	elif test "x$prefix" != "xNONE"; then
+    		ZLIB_CFLAGS="-I$includedir"
+  	fi
+
+	oldcflags=$CFLAGS
+	oldlibs=$LIBS
+	oldcppflags=$CPPFLAGS
+	CFLAGS="$CFLAGS $MPD_CFLAGS $ZLIB_CFLAGS -I."
+	LIBS="$LIBS $MPD_LIBS $ZLIB_LIBS"
+	CPPFLAGS=$CFLAGS
+	AC_CHECK_HEADER(zlib.h,,enable_zlib=no)
+	if test x$enable_zlib = xyes; then
+		AC_CHECK_LIB(z,inflate,[MPD_LIBS="$MPD_LIBS $ZLIB_LIBS";MPD_CFLAGS="$MPD_CFLAGS $ZLIB_CFLAGS";],enable_zlib=no)
+	fi
+	if test x$enable_zlib = xyes; then
+		AC_DEFINE(HAVE_ZLIB,1,[Define to use gzip and pkzip decompression])
+	else
+		AC_MSG_WARN([zlib lib needed for gzip and pkzip decompression support -- disabling zlib support])
+	fi
+	CFLAGS=$oldcflags
+	LIBS=$oldlibs
+	CPPFLAGS=$oldcppflags
+fi
+
+if test x$enable_bzip2 = xyes; then
+  	if test "x$bzip2_libraries" != "x" ; then
+  		BZIP2_LIBS="-L$bzip2_libraries"
+  	elif test "x$bzip2_prefix" != "x" ; then
+		BZIP2_LIBS="-L$bzip2_prefix/lib"
+  	elif test "x$prefix" != "xNONE"; then
+    		BZIP2_LIBS="-L$libdir"
+  	fi
+
+ 	BZIP2_LIBS="$BZIP2_LIBS -lbz2"
+
+  	if test "x$bzip2_includes" != "x" ; then
+  		BZIP2_CFLAGS="-I$bzip2_includes"
+  	elif test "x$bzip2_prefix" != "x" ; then
+    		BZIP2_CFLAGS="-I$bzip2_prefix/include"
+  	elif test "x$prefix" != "xNONE"; then
+    		BZIP2_CFLAGS="-I$includedir"
+  	fi
+
+	oldcflags=$CFLAGS
+	oldlibs=$LIBS
+	oldcppflags=$CPPFLAGS
+	CFLAGS="$CFLAGS $MPD_CFLAGS $BZIP2_CFLAGS -I."
+	LIBS="$LIBS $MPD_LIBS $BZIP2_LIBS"
+	CPPFLAGS=$CFLAGS
+	AC_CHECK_HEADER(bzlib.h,,enable_bzip2=no)
+	if test x$enable_bzip2 = xyes; then
+		AC_CHECK_LIB(bz2,BZ2_bzdopen,[MPD_LIBS="$MPD_LIBS $BZIP2_LIBS";MPD_CFLAGS="$MPD_CFLAGS $BZIP2_CFLAGS";],enable_bzip2=no)
+	fi
+	if test x$enable_bzip2 = xyes; then
+		AC_DEFINE(HAVE_BZIP2,1,[Define to use bzip2 decompression])
+	else
+		AC_MSG_WARN([bzip2 lib needed for bzip2 decompression support -- disabling bzip2 support])
+	fi
+	CFLAGS=$oldcflags
+	LIBS=$oldlibs
+	CPPFLAGS=$oldcppflags
+fi
+
 AC_OUTPUT(src/mp4ff/Makefile doc/Makefile src/Makefile Makefile )
 
 echo ""
@@ -754,6 +842,18 @@ else
 	echo " MOD support ...................disabled"
 fi
 
+if test x$enable_zlib = xyes; then
+	echo " zlib support ..................enabled"
+else
+	echo " zlib support ..................disabled"
+fi
+
+if test x$enable_bzip2 = xyes; then
+	echo " bzip2 support .................enabled"
+else
+	echo " bzip2 support .................disabled"
+fi
+
 if
 	test x$enable_mp3 = xno &&
 	test x$enable_oggvorbis = xno &&
diff --git a/src/Makefile.am b/src/Makefile.am
index 0207cb9..7e7859c 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -30,6 +30,7 @@ mpd_headers = \
 	audio.h \
 	audioOutput.h \
 	buffer2array.h \
+	bunzip2.h \
 	charConv.h \
 	command.h \
 	conf.h \
@@ -37,6 +38,7 @@ mpd_headers = \
 	decode.h \
 	directory.h \
 	gcc.h \
+	gunzip.h \
 	inputPlugin.h \
 	inputPlugins/_flac_common.h \
 	inputPlugins/_ogg_common.h \
@@ -70,6 +72,7 @@ mpd_headers = \
 	tag.h \
 	tagTracker.h \
 	tree.h \
+	unpack.h \
 	utf8.h \
 	utils.h \
 	volume.h \
@@ -83,12 +86,14 @@ mpd_SOURCES = \
 	audio.c \
 	audioOutput.c \
 	buffer2array.c \
+	bunzip2.c \
 	charConv.c \
 	command.c \
 	conf.c \
 	dbUtils.c \
 	decode.c \
 	directory.c \
+	gunzip.c \
 	inputPlugin.c \
 	inputStream.c \
 	inputStream_file.c \
@@ -121,6 +126,7 @@ mpd_SOURCES = \
 	tagTracker.c \
 	tree.c \
 	utils.c \
+	unpack.c \
 	volume.c \
 	utf8.c \
 	zeroconf.c
diff --git a/src/bunzip2.c b/src/bunzip2.c
new file mode 100644
index 0000000..c4c3206
--- /dev/null
+++ b/src/bunzip2.c
@@ -0,0 +1,56 @@
+/* the Music Player Daemon (MPD)
+ * (c)2003-2006 by Warren Dukes (warren.dukes@gmail.com)
+ * This project's homepage is: http://www.musicpd.org
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "bunzip2.h"
+
+#ifdef HAVE_BZIP2
+
+#include <bzlib.h>
+#include <stdlib.h>
+
+int bunzip2(char *path, void **data, size_t *size)
+{
+	BZFILE* bf;
+	int nr;
+
+	if (!(bf = BZ2_bzopen(path, "rb"))) {
+		ERROR("unbzip2: not bzip2 file\n");
+		return 0;
+	}
+
+	*data = NULL;
+	*size = 0;
+
+	for(;;) {
+		*data = realloc(*data, *size + 2048);
+		if (!*data) {
+			ERROR("unbzip2: out of memory\n");
+			BZ2_bzclose(bf);
+			return 0;
+		}
+		nr = BZ2_bzread(bf, (char *)(*data) + *size, 2048);
+		if (nr <= 0) break;
+		*size += nr;
+	}
+
+	BZ2_bzclose(bf);
+
+	return 1;
+}
+
+#endif
diff --git a/src/bunzip2.h b/src/bunzip2.h
new file mode 100644
index 0000000..39ac0b9
--- /dev/null
+++ b/src/bunzip2.h
@@ -0,0 +1,30 @@
+/* the Music Player Daemon (MPD)
+ * (c)2003-2006 by Warren Dukes (warren.dukes@gmail.com)
+ * This project's homepage is: http://www.musicpd.org
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "../config.h"
+
+#ifdef HAVE_BZIP2
+
+#include <stdlib.h>
+int bunzip2(char *path, void **data, size_t *size);
+
+#else
+
+#define bunzip2(path, data, size) 0
+
+#endif
diff --git a/src/gunzip.c b/src/gunzip.c
new file mode 100644
index 0000000..85a7d76
--- /dev/null
+++ b/src/gunzip.c
@@ -0,0 +1,230 @@
+/* the Music Player Daemon (MPD)
+ * (c)2003-2006 by Warren Dukes (warren.dukes@gmail.com)
+ * This project's homepage is: http://www.musicpd.org
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "gunzip.h"
+
+#ifdef HAVE_ZLIB
+
+#include <zlib.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+
+#define MAGIC_SIZE     2
+#define MODE_DEFLATE   8
+
+#define	GZIP_MAGIC     "\037\213"
+
+#define GZIP_MODE      2
+#define GZIP_FLAGS     3
+#define GZIP_FLAG_ASCII        0x01 /* bit 0 set: file probably ascii text */
+#define GZIP_FLAG_HEAD_CRC     0x02 /* bit 1 set: header CRC present */
+#define GZIP_FLAG_EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define GZIP_FLAG_ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define GZIP_FLAG_COMMENT      0x10 /* bit 4 set: file comment present */
+#define GZIP_FLAG_RESERVED     0xE0 /* bits 5..7: reserved */
+
+#define GZIP_HEADER_SIZE 10
+#define GZIP_FOOTER_SIZE 8
+
+#define PKZIP_MAGIC    "\120\113\003\004" /* Magic header for pkzip files */
+/* PKZIP header definitions */
+#define PKZIP_LOCSIG 0x04034b50L      /* four-byte lead-in (lsb first) */
+#define PKZIP_LOCFLG 6                /* offset of bit flag */
+#define PKZIP_CRPFLG 1                /*  bit for encrypted entry */
+#define PKZIP_EXTFLG 8                /*  bit for extended local header */
+#define PKZIP_LOCHOW 8                /* offset of compression method */
+#define PKZIP_LOCTIM 10               /* file mod time (for decryption) */
+#define PKZIP_LOCCRC 14               /* offset of crc */
+#define PKZIP_LOCSIZ 18               /* offset of compressed size */
+#define PKZIP_LOCLEN 22               /* offset of uncompressed length */
+#define PKZIP_LOCFIL 26               /* offset of file name field length */
+#define PKZIP_LOCEXT 28               /* offset of extra field length */
+#define PKZIP_LOCHDR 30               /* size of local header, including sig */
+#define PKZIP_EXTHDR 16               /* size of extended local header, inc sig */
+#define PKZIP_RAND_HEAD_LEN  12       /* length of encryption random header */
+
+/* Macros for getting two-byte and four-byte header values */
+#define SH(p) ((unsigned short)(unsigned char)((p)[0]) | \
+        ((unsigned short)(unsigned char)((p)[1]) << 8))
+#define LG(p) ((unsigned long)(SH(p)) | ((unsigned long)(SH((p)+2)) << 16))
+
+static int skip_string(FILE *fp)
+{
+	char c;
+
+	do {
+		if (fread(&c, 1, 1, fp) != 1)
+		    return 0;
+	} while (c != 0);
+
+	return 1;
+}
+
+static size_t skip(FILE *fp, size_t num_bytes)
+{
+	unsigned char buf[32];
+	size_t bytes_read;
+
+	while (num_bytes != 0) {
+	    bytes_read = fread(buf, 1,
+		    (num_bytes > sizeof(buf)) ?
+		    sizeof(buf) : num_bytes, fp);
+	    num_bytes -= bytes_read;
+	    if (bytes_read == 0) return 0;
+	}
+
+	return 1;
+}
+
+static int read_header(FILE *fp)
+{
+	unsigned char buffer[100];
+
+	if (fread(buffer, MAGIC_SIZE, 1, fp) != 1)
+		return 0;
+
+	if (!memcmp(buffer, GZIP_MAGIC, MAGIC_SIZE)) {
+		/* gzip format */
+		unsigned char flags;
+
+		if (fread(&buffer[MAGIC_SIZE],
+			    GZIP_HEADER_SIZE - MAGIC_SIZE,
+			    1, fp) != 1)
+			return 0;
+
+		if (buffer[GZIP_MODE] != MODE_DEFLATE)
+			return 0;
+
+		flags = buffer[GZIP_FLAGS];
+
+		if (flags & GZIP_FLAG_RESERVED)
+			return 0;
+
+		if (flags & GZIP_FLAG_EXTRA_FIELD) {
+			unsigned char tmp[2];
+
+			if (fread(tmp, 2, 1, fp) != 1)
+				return 0;
+			if (!skip(fp, tmp[0] | (tmp[0] << 8)))
+				return 0;
+		}
+
+		if (flags & GZIP_FLAG_ORIG_NAME)
+			if (!skip_string(fp))
+				return 0;
+
+		if (flags & GZIP_FLAG_COMMENT)
+			if (!skip_string(fp))
+				return 0;
+
+		if (flags & GZIP_FLAG_HEAD_CRC)
+			if (!skip(fp, 2))
+				return 0;
+
+		return 1;
+	}
+	else if (!memcmp(buffer, PKZIP_MAGIC, MAGIC_SIZE)) {
+		/* pkzip format */
+		if (fread(&buffer[MAGIC_SIZE],
+			    PKZIP_LOCHDR - MAGIC_SIZE, 1, fp) != 1)
+			return 0;
+
+		if (LG(buffer) != PKZIP_LOCSIG)
+			return 0;
+		if (buffer[PKZIP_LOCHOW] != MODE_DEFLATE)
+			return 0;
+		if (!skip(fp, SH(buffer + PKZIP_LOCFIL)))
+			return 0;
+		if (!skip(fp, SH(buffer + PKZIP_LOCEXT)))
+			return 0;
+
+		return 1;
+	}
+
+	return 0;
+}
+
+int gunzip(char *path, void **data, size_t *size)
+{
+	int nr, ao, zr;
+	FILE *fp;
+	z_stream zs;
+	unsigned char buf[2048];
+
+	if (!(fp = fopen(path, "rb")))
+		return 0;
+
+	if (!read_header(fp)) {
+		ERROR("gunzip: no gzip file\n");
+		fclose(fp);
+		return 0;
+	}
+
+	zs.zalloc = NULL;
+	zs.zfree = NULL;
+	zs.opaque = NULL;
+	zs.avail_in = 0;
+	zs.avail_out = 0;
+
+	if (inflateInit2(&zs, -MAX_WBITS) != Z_OK) {
+		ERROR("error while initializing zlib\n");
+		fclose(fp);
+		return 0;
+	}
+
+	*data = NULL;
+	*size = 0;
+
+	for (;;) {
+		if (zs.avail_in == 0) {
+			nr = fread(buf, 1, sizeof(buf), fp);
+			if (nr <= 0)
+				break;
+			zs.next_in = buf;
+			zs.avail_in = nr;
+		}
+
+		if (zs.avail_out == 0) {
+			*data = realloc(*data, *size + 2048);
+			if (!*data)
+			{
+				ERROR("gunzip: out of memory\n");
+				inflateEnd(&zs);
+				fclose(fp);
+				return 0;
+			}
+			zs.next_out = (char *)(*data) + *size;
+			zs.avail_out = 2048;
+		}
+
+		ao = zs.avail_out;
+		zr = inflate(&zs, Z_NO_FLUSH);
+		*size += ao - zs.avail_out;
+
+		if (zr != Z_OK)
+			break;
+	}
+
+	inflateEnd(&zs);
+	fclose(fp);
+
+	return 1;
+}
+
+#endif
diff --git a/src/gunzip.h b/src/gunzip.h
new file mode 100644
index 0000000..1bcf679
--- /dev/null
+++ b/src/gunzip.h
@@ -0,0 +1,31 @@
+/* the Music Player Daemon (MPD)
+ * (c)2003-2006 by Warren Dukes (warren.dukes@gmail.com)
+ * This project's homepage is: http://www.musicpd.org
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "../config.h"
+
+#ifdef HAVE_ZLIB
+
+#include <stdlib.h>
+
+int gunzip(char *path, void **data, size_t *size);
+
+#else
+
+#define gunzip(path, data, size) 0
+
+#endif
diff --git a/src/inputPlugins/mod_plugin.c b/src/inputPlugins/mod_plugin.c
index a73c267..d4cc1a4 100644
--- a/src/inputPlugins/mod_plugin.c
+++ b/src/inputPlugins/mod_plugin.c
@@ -25,6 +25,7 @@
 #include "../log.h"
 #include "../pcm_utils.h"
 #include "../playerData.h"
+#include "../unpack.h"
 
 #include <stdio.h>
 #include <unistd.h>
@@ -130,6 +131,95 @@ static void mod_finishMikMod(void)
 	MikMod_Exit();
 }
 
+typedef struct _mod_Buffer {
+	MREADER reader;
+	SBYTE *data;
+	size_t size;
+	size_t offset;
+	int eof;
+} mod_Buffer;
+
+static BOOL mod_buf_seek(struct MREADER * reader, long offset, int whence)
+{
+	mod_Buffer *b = (mod_Buffer*)(reader);
+	long new_offset;
+
+	switch (whence) {
+		case SEEK_SET: new_offset = offset; break;
+		case SEEK_CUR: new_offset = b->offset + offset; break;
+		case SEEK_END: new_offset = b->size + offset; break;
+		default: return -1;
+	}
+	if (new_offset < 0 || new_offset > b->size)
+		return -1;
+
+	b->offset = new_offset;
+	b->eof = 0;
+
+	return 0;
+}
+
+static long mod_buf_tell(struct MREADER * reader)
+{
+	mod_Buffer *b = (mod_Buffer*)(reader);
+
+	return b->offset;
+}
+  
+static BOOL mod_buf_read(struct MREADER * reader, void * ptr, size_t size)
+{
+	mod_Buffer *b = (mod_Buffer*)(reader);
+	size_t bytes_read = 0;
+
+	if (b->offset + size > b->size) {
+		bytes_read = b->size - b->offset;
+		b->eof = 1;
+	} else bytes_read = size;
+
+	memcpy(ptr, b->data + b->offset, bytes_read);
+	b->offset += bytes_read;
+
+	return bytes_read;
+}
+
+static int mod_buf_get(struct MREADER * reader)
+{
+	mod_Buffer *b = (mod_Buffer*)(reader);
+
+	if (b->offset == b->size) {
+		b->eof = 1;
+		return EOF;
+	}
+	return (unsigned char)b->data[b->offset++];
+}
+
+static BOOL mod_buf_eof(struct MREADER * reader)
+{
+	mod_Buffer *b = (mod_Buffer*)(reader);
+
+	return b->eof;
+}
+
+static MODULE *mod_load(char *path, int maxchan, BOOL curious)
+{
+	mod_Buffer buf;
+	MODULE *result;
+
+	if (unpack(path, &buf.data, &buf.size)) {
+		buf.reader.Seek = &mod_buf_seek;
+		buf.reader.Tell = &mod_buf_tell;
+		buf.reader.Read = &mod_buf_read;
+		buf.reader.Get = &mod_buf_get;
+		buf.reader.Eof = &mod_buf_eof;
+		result = Player_LoadGeneric((MREADER*)(&buf),
+			maxchan, curious);
+		free(buf.data);
+	} else 
+		result = Player_Load(path, maxchan, curious);
+
+	return result;
+}
+
 typedef struct _mod_Data {
 	MODULE *moduleHandle;
 	SBYTE *audio_buffer;
@@ -140,7 +230,7 @@ static mod_Data *mod_open(char *path)
 	MODULE *moduleHandle;
 	mod_Data *data;
 
-	if (!(moduleHandle = Player_Load(path, 128, 0)))
+	if (!(moduleHandle = mod_load(path, 128, 0)))
 		return NULL;
 
 	data = xmalloc(sizeof(mod_Data));
@@ -148,6 +238,9 @@ static mod_Data *mod_open(char *path)
 	data->audio_buffer = xmalloc(MIKMOD_FRAME_SIZE);
 	data->moduleHandle = moduleHandle;
 
+	data->moduleHandle->loop = 0; /* some modules fall in infinite loop */
+	data->moduleHandle->wrap = 0; /* so we need to prevent this */
+
 	Player_Start(data->moduleHandle);
 
 	return data;
@@ -166,6 +259,7 @@ static int mod_decode(OutputBuffer * cb, DecoderControl * dc, char *path)
 	mod_Data *data;
 	float time = 0.0;
 	int ret;
+	int prev_sngpos;
 	float secPerByte;
 
 	if (mod_initMikMod() < 0)
@@ -177,6 +271,8 @@ static int mod_decode(OutputBuffer * cb, DecoderControl * dc, char *path)
 		return -1;
 	}
 
+	prev_sngpos = data->moduleHandle->sngpos;
+
 	dc->audioFormat.bits = 16;
 	dc->audioFormat.sampleRate = 44100;
 	dc->audioFormat.channels = 2;
@@ -199,6 +295,11 @@ static int mod_decode(OutputBuffer * cb, DecoderControl * dc, char *path)
 		if (!Player_Active())
 			break;
 
+		if (prev_sngpos < data->moduleHandle->sngpos)
+			prev_sngpos = data->moduleHandle->sngpos;
+		else if (prev_sngpos > data->moduleHandle->sngpos)
+			break; /* disable looping any way */
+
 		ret = VC_WriteBytes(data->audio_buffer, MIKMOD_FRAME_SIZE);
 		time += ret * secPerByte;
 		sendDataToOutputBuffer(cb, NULL, dc, 0,
@@ -225,48 +326,62 @@ static MpdTag *modTagDup(char *file)
 {
 	MpdTag *ret = NULL;
 	MODULE *moduleHandle;
-	char *title;
+	char *title = NULL;
 
 	if (mod_initMikMod() < 0) {
 		DEBUG("modTagDup: Failed to initialize MikMod\n");
 		return NULL;
 	}
 
-	if (!(moduleHandle = Player_Load(file, 128, 0))) {
+	if (!(moduleHandle = mod_load(file, 128, 0))) {
 		DEBUG("modTagDup: Failed to open file: %s\n", file);
 		MikMod_Exit();
 		return NULL;
 
 	}
-	Player_Free(moduleHandle);
 
 	ret = newMpdTag();
 
 	ret->time = 0;
-	title = xstrdup(Player_LoadTitle(file));
+	if (moduleHandle->songname)
+		title = xstrdup(moduleHandle->songname);
 	if (title)
 		addItemToMpdTag(ret, TAG_ITEM_TITLE, title);
 
+	Player_Free(moduleHandle);
+
 	MikMod_Exit();
 
 	return ret;
 }
 
-static char *modSuffixes[] = { "amf",
-	"dsm",
-	"far",
-	"gdm",
-	"imf",
-	"it",
-	"med",
-	"mod",
-	"mtm",
-	"s3m",
-	"stm",
-	"stx",
-	"ult",
-	"uni",
-	"xm",
+#define MOD_SUFFIXES(z) \
+	"669" z, \
+	"amf" z, \
+	"dsm" z, \
+	"far" z, \
+	"gdm" z, \
+	"imf" z, \
+	"it" z, \
+	"med" z, \
+	"mod" z, \
+	"mtm" z, \
+	"s3m" z, \
+	"stm" z, \
+	"stx" z, \
+	"ult" z, \
+	"uni" z, \
+	"xm" z
+
+static char *modSuffixes[] = {
+        MOD_SUFFIXES(""),
+#ifdef HAVE_ZLIB
+        MOD_SUFFIXES(".gz"),
+        MOD_SUFFIXES(".zip"),
+#endif
+#ifdef HAVE_BZIP2
+        MOD_SUFFIXES(".bz2"),
+#endif
 	NULL
 };
 
diff --git a/src/ls.c b/src/ls.c
index 6c9e9ba..e32e604 100644
--- a/src/ls.c
+++ b/src/ls.c
@@ -27,6 +27,7 @@
 #include <dirent.h>
 #include <stdio.h>
 #include <errno.h>
+#include <string.h>
 
 static char *remoteUrlPrefixes[] = {
 	"http://",
@@ -215,13 +216,21 @@ static int isFile(char *utf8file, time_t * mtime)
 char *getSuffix(char *utf8file)
 {
 	char *ret = NULL;
+	char *prev = NULL;
 
 	while (*utf8file) {
-		if (*utf8file == '.')
+		if (*utf8file == '.') {
+			prev = ret;
 			ret = utf8file + 1;
+		}
 		utf8file++;
 	}
 
+	if (prev && (!strcasecmp(ret, "zip") ||
+		    !strcasecmp(ret, "gz") ||
+		    !strcasecmp(ret, "bz2")))
+		ret = prev;
+
 	return ret;
 }
 
diff --git a/src/unpack.c b/src/unpack.c
new file mode 100644
index 0000000..48990a2
--- /dev/null
+++ b/src/unpack.c
@@ -0,0 +1,40 @@
+/* the Music Player Daemon (MPD)
+ * (c)2003-2006 by Warren Dukes (warren.dukes@gmail.com)
+ * This project's homepage is: http://www.musicpd.org
+ * 
+ * Unpack file contents from various of archives to memory.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "unpack.h"
+#include "gunzip.h"
+#include "bunzip2.h"
+
+#include <string.h>
+
+int unpack(char *path, void **data, size_t *size)
+{
+    char *s;
+
+    if (!(s = strrchr(path, '.')))
+	    return 0;
+
+    if (!strcasecmp(s, ".gz") || !strcasecmp(s, ".zip"))
+	    return gunzip(path, data, size);
+    if (!strcasecmp(s, ".bz2"))
+	    return bunzip2(path, data, size);
+
+    return 0;
+}
diff --git a/src/unpack.h b/src/unpack.h
new file mode 100644
index 0000000..ab61a86
--- /dev/null
+++ b/src/unpack.h
@@ -0,0 +1,23 @@
+/* the Music Player Daemon (MPD)
+ * (c)2003-2006 by Warren Dukes (warren.dukes@gmail.com)
+ * This project's homepage is: http://www.musicpd.org
+ *
+ * Unpack file contents from various of archives to memory.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+int unpack(char *path, void **data, size_t *size);
